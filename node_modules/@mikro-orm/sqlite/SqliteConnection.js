"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteConnection = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const knex_1 = require("@mikro-orm/knex");
const core_1 = require("@mikro-orm/core");
class SqliteConnection extends knex_1.AbstractSqlConnection {
    createKnex() {
        this.client = this.createKnexClient(this.getPatchedDialect());
        this.connected = true;
    }
    async connect() {
        this.createKnex();
        await (0, fs_extra_1.ensureDir)((0, path_1.dirname)(this.config.get('dbName')));
        await this.getKnex().raw('pragma foreign_keys = on');
    }
    getDefaultClientUrl() {
        return '';
    }
    getClientUrl() {
        return '';
    }
    async loadFile(path) {
        const conn = await this.getKnex().client.acquireConnection();
        await conn.exec((await (0, fs_extra_1.readFile)(path)).toString());
        await this.getKnex().client.releaseConnection(conn);
    }
    getKnexOptions(type) {
        return core_1.Utils.mergeConfig({
            client: type,
            connection: {
                filename: this.config.get('dbName'),
            },
            pool: this.config.get('pool'),
            useNullAsDefault: true,
        }, this.config.get('driverOptions'));
    }
    transformRawResult(res, method) {
        if (method === 'get') {
            return res[0];
        }
        if (method === 'all') {
            return res;
        }
        if (Array.isArray(res)) {
            return {
                insertId: res[res.length - 1]?.id ?? 0,
                affectedRows: res.length,
                row: res[0],
                rows: res,
            };
        }
        return {
            insertId: res.lastID,
            affectedRows: res.changes,
        };
    }
    /**
     * monkey patch knex' sqlite Dialect so it returns inserted id when doing raw insert query
     */
    getPatchedDialect() {
        const { Sqlite3Dialect, Sqlite3DialectTableCompiler } = knex_1.MonkeyPatchable;
        if (Sqlite3Dialect.prototype.__patched) {
            return Sqlite3Dialect;
        }
        const processResponse = Sqlite3Dialect.prototype.processResponse;
        Sqlite3Dialect.prototype.__patched = true;
        Sqlite3Dialect.prototype.processResponse = (obj, runner) => {
            if (obj.method === 'raw' && this.isRunQuery(obj.sql)) {
                return obj.response ?? obj.context;
            }
            return processResponse(obj, runner);
        };
        Sqlite3Dialect.prototype._query = (connection, obj) => {
            const callMethod = this.getCallMethod(obj);
            return new Promise((resolve, reject) => {
                /* istanbul ignore if */
                if (!connection?.[callMethod]) {
                    return reject(new Error(`Error calling ${callMethod} on connection.`));
                }
                connection[callMethod](obj.sql, obj.bindings, function (err, response) {
                    if (err) {
                        return reject(err);
                    }
                    obj.response = response;
                    obj.context = this;
                    return resolve(obj);
                });
            });
        };
        /* istanbul ignore next */
        Sqlite3DialectTableCompiler.prototype.foreign = function (foreignInfo) {
            foreignInfo.column = Array.isArray(foreignInfo.column)
                ? foreignInfo.column
                : [foreignInfo.column];
            foreignInfo.column = foreignInfo.column.map((column) => this.client.customWrapIdentifier(column, (a) => a));
            foreignInfo.inTable = this.client.customWrapIdentifier(foreignInfo.inTable, (a) => a);
            foreignInfo.references = Array.isArray(foreignInfo.references)
                ? foreignInfo.references
                : [foreignInfo.references];
            foreignInfo.references = foreignInfo.references.map((column) => this.client.customWrapIdentifier(column, (a) => a));
            // quoted versions
            const column = this.formatter.columnize(foreignInfo.column);
            const inTable = this.formatter.columnize(foreignInfo.inTable);
            const references = this.formatter.columnize(foreignInfo.references);
            const keyName = this.formatter.columnize(foreignInfo.keyName);
            const addColumnQuery = this.sequence.find((query) => query.sql.includes(`add column ${column[0]}`));
            // no need for temp tables if we just add a column
            if (addColumnQuery) {
                const onUpdate = foreignInfo.onUpdate ? ` on update ${foreignInfo.onUpdate}` : '';
                const onDelete = foreignInfo.onDelete ? ` on delete ${foreignInfo.onDelete}` : '';
                addColumnQuery.sql += ` constraint ${keyName} references ${inTable} (${references})${onUpdate}${onDelete}`;
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const compiler = this;
            if (this.method !== 'create' && this.method !== 'createIfNot') {
                this.pushQuery({
                    sql: `PRAGMA table_info(${this.tableName()})`,
                    statementsProducer(pragma, connection) {
                        return compiler.client
                            .ddl(compiler, pragma, connection)
                            .foreign(foreignInfo);
                    },
                });
            }
        };
        return Sqlite3Dialect;
    }
    isRunQuery(query) {
        query = query.trim().toLowerCase();
        if ((query.startsWith('insert into') || query.startsWith('update ')) && query.includes(' returning ')) {
            return false;
        }
        return query.startsWith('insert into') ||
            query.startsWith('update') ||
            query.startsWith('delete') ||
            query.startsWith('truncate');
    }
    getCallMethod(obj) {
        if (obj.method === 'raw') {
            const query = obj.sql.trim().toLowerCase();
            if ((query.startsWith('insert into') || query.startsWith('update ')) && query.includes(' returning ')) {
                return 'all';
            }
            if (this.isRunQuery(query)) {
                return 'run';
            }
        }
        /* istanbul ignore next */
        switch (obj.method) {
            case 'insert':
            case 'update':
                return obj.returning ? 'all' : 'run';
            case 'counter':
            case 'del':
                return 'run';
            default:
                return 'all';
        }
    }
}
exports.SqliteConnection = SqliteConnection;
